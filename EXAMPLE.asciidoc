= Twiliofaces
Fiorenzo Pizza<fiorenzo.pizza@gmail.com>
:imagesdir: assets
:homepage: http://twiliofaces.org

== http://twiliofaces.org[Twiliofaces] Come usare Twilio nelle tue applicazione java ee!

Da poco meno di un anno anche un italia è sbarcata http://twilio.com[Twilio], compagnia americana che offre servizi telefonici in cloud 
tramite l'uso di semplici api. La semplicita d'uso delle sue api consente agevolmente di gestire servizi vocali e 
di messaggistica direttamente integrabili in applicazioni pre-esistenti.
Non serve avere server voip dedicato, basta avere un indirizzo pubblico raggiungibile dai
server twilio, crerare un account e iniziare a sperimentare.
L'account gratuito consente di scegliere un numero telefonico della numerazione italiana, permette
di abilitare un numero pre-esistente per testare l'interazione coi servizi twilio.
Le api per utilizzare i servizi twilio, scariucabili gratuitamente da 
https://github.com/twilio[twilio@github], sono manutenute dalla societa' e coprono i principali linguaggi di programmazione 
tra cui java.

Cosa vedrete in questo articolo

. Come funziona twilio
. Come usate le api java twilio e twiliofaces
. Come verificare il vs twiml  e come testare le vs applicazioni

== twilio in breve

Quando qualcuno chiama il vs numero, twilio effettua una chiamata al link che avete configurato nella sezione numeri 
del vs dashboard. Twilio effettua una request post o get (a seconda di come configurato) all'url (che puo' 
essere http/https con o senza username/password, trasmettendo una serie di parametri (vd questo link per maggiori 
informazioni).
La ns applicazione deve produrre TwiML (un dialetto xml - le cui regole sono descritte qui) contenente una serie 
di "istruzioni" (chiamati verbi - l'intero set di verbi/parametri e' descritto nella coumentazione twilio.) che 
dicono a twilio cosa fare, ad esempio:

- http://www.twilio.com/docs/api/2010-04-01/twiml/hangup[rifiutare una chiamata]:
....
<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Hangup/>
</Response>
....
- http://www.twilio.com/docs/api/twiml/play[suonare un mp3]:
....
<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Play loop="10">https://api.twilio.com/cowbell.mp3</Play>
</Response>
....
- http://www.twilio.com/docs/api/2010-04-01/twiml/gather[richiedere l'inserimento di numeri]:
....
<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Gather timeout="10" finishOnKey="*">
        <Say>Please enter your pin number and then press star.</Say>
    </Gather>
</Response>
....
- http://www.twilio.com/docs/api/twiml/record[registrare una chiamata]:
....
<?xml version="1.0" encoding="UTF-8"?>
<Response>
    <Record timeout="10" transcribe="true" />
</Response>
....

== per iniziare:

. Create un nuovo account twilio: https://www.twilio.com/try-twilio
. Scegliete un numero di telefono e fornite un vs numero con il quale farete le chiamate di test (twilio permette di effettuare e ricevere chiamate soltanto verso/da un numero verificato)
. Per creare un applicazione con le api twilio, dovete copiare dalla dashboard:
.. Account Sid
.. App SID
.. Auth Token

=== Creiamo un progetto Maven e aggiungiamo twilio.sdk e twiliofaces tra le dipendenze del pom.xml

----
...
<dependencies>
  <dependency>
   	<groupId>com.twilio.sdk</groupId>
	<artifactId>twilio-java-sdk</artifactId>
	<version>${twilio.sdk.version}</version>
	<scope>compile</scope>
  </dependency>
  <dependency>
	<groupId>org.twiliofaces</groupId>
	<artifactId>twiliofaces</artifactId>
	<version>${twiliofaces.version}</version>
	<scope>compile</scope>
  </dependency>
</dependencies>
...
----

Di seguito vedremo quali vantaggi si hanno nell'utilizzare twiliofaces, invece della libreria java twilio-sdk.


== Come generare twiml usando twilio-sdk ed usando twiliofaces tramite tag jsf

*Per mostrare la semplicita' d'uso di twiliofaces rispetto alle api standard twilio, gestiamo un semplice hangup*.
Immaginiamo di aver configurato il nostro numero per rifiutare tutte le chiamate che riceviamo.
Usando twilio-sdk, generiamo la index.jsp:

----
<%@ page import="it.ictgroup.test.TwimlGenerator" %>
<%@page contentType="text/xml" %>
<%=	TwimlGenerator.hangup(); %>
----
ed il nostro TwimlGenerator:

----
package it.ictgroup.test;

import com.twilio.sdk.verbs.*;

public class TwimlGenerator {

	public static String hangup(){
	    TwiMLResponse response = new TwiMLResponse();
            try {
	       Hangup hangup = new Hangup();
	       response.append(hangup);
            } catch (TwiMLException e) {
               e.printStackTrace();
            }
            return(response.toXML());
      }
}
----

Bene utilizzando twiliofaces, basta creare un progetto web contenente:

- aggiungere un file *WEB-INF/beans.xml*:

----
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="
      http://java.sun.com/xml/ns/javaee 
      http://java.sun.com/xml/ns/javaee/beans_1_0.xsd">
</beans>

----

- aggiungere un file *WEB-INF/faces-config.xml*:

----
<?xml version="1.0" encoding="UTF-8"?>
<faces-config
    xmlns="http://java.sun.com/xml/ns/javaee"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-facesconfig_2_1.xsd"
    version="2.1">
</faces-config>
----

e infine creare la pagina *index.xhtml*:

----

<?xml version="1.0" encoding="UTF-8"?>
<f:view xmlns="http://www.w3c.org/1999/xhtml"
	xmlns:f="http://java.sun.com/jsf/core"
	xmlns:tf="http://twiliofaces.org/twiliofaces">
	<tf:response>
		<tf:hangup />
	</tf:response>
</f:view>

----

Non e' piu' semplice? Facciamo qualche esempio piu' complesso.

*Caso d'uso: riconosciamo il chiamante e richiediamo nome/cognome la prima volta, altrimenti rifiutiamo la chiamata*

https://github.com/twiliofaces/twilioscope-example[vedi esempio completo]

Con twiliofaces, creiamo un controller con scope di request e iniettiamoci il parametro From. 
Se From non corrisponde al numero che conosciamo, generiamo una voce che richiede nome e cognome (usando il verbo Say),
registriamo il messaggio vocale (usando il verbo Record), infine salutiamo il nuovo registrato.
Se invece corrisponde ad un numero noto, generiamo un hangup.

pagina index.jsf che in base al numero del chiamante stabilisce cosa fare:

----
<?xml version="1.0" encoding="UTF-8"?>
<f:view xmlns="http://www.w3c.org/1999/xhtml"
	xmlns:f="http://java.sun.com/jsf/core"
	xmlns:c="http://java.sun.com/jsp/jstl/core"
	xmlns:ui="http://java.sun.com/jsf/facelets"
	xmlns:tf="http://twiliofaces.org/twiliofaces">
	<f:event type="preRenderView" listener="#{userController.log}" />
	<c:choose>
		<c:when test="#{userController.newUser}">
			<ui:include src="new-user.xhtml" />
		</c:when>
		<c:otherwise>
			<ui:include src="hangup.xhtml" />
		</c:otherwise>
	</c:choose>
</f:view>
----
vediamo il codice dei due file da includere, new-user.xhtml:

----
<ui:composition xmlns="http://www.w3c.org/1999/xhtml"
	xmlns:f="http://java.sun.com/jsf/core"
	xmlns:h="http://java.sun.com/jsf/html"
	xmlns:ui="http://java.sun.com/jsf/facelets"
	xmlns:tf="http://twiliofaces.org/twiliofaces">
	<tf:response>
		<tf:say voice="woman" language="it">Ciao, non ti conosco, come ti chiami?</tf:say>
		<tf:record method="POST" maxLength="5" finishOnKey="*"
			action="./thanks.jsf"></tf:record>
	</tf:response>
</ui:composition>
----
e hangup.xhtml
----
<ui:composition xmlns="http://www.w3c.org/1999/xhtml"
	xmlns:ui="http://java.sun.com/jsf/facelets"
	xmlns:tf="http://twiliofaces.org/twiliofaces">
	<tf:response>
		<tf:hangup />
	</tf:response>
</ui:composition>
----

java controller che registra i chiamanti e decide cosa fare:

----
package org.twiliofaces.test.twilioscope.controller;

import java.io.Serializable;

import javax.enterprise.inject.Instance;
import javax.inject.Inject;
import javax.inject.Named;

import org.twiliofaces.annotations.TwilioScope;
import org.twiliofaces.annotations.notification.CallSid;
import org.twiliofaces.annotations.notification.From;
import org.twiliofaces.annotations.notification.RecordingUrl;
import org.twiliofaces.extension.TwilioScoped;
import org.twiliofaces.test.twilioscope.model.User;
import org.twiliofaces.test.twilioscope.repository.UserRepository;

@TwilioScope
@Named
public class UserController implements TwilioScoped, Serializable {

	private static final long serialVersionUID = 1L;

	@Inject
	UserRepository userRepository;

	@Inject
	@CallSid
	Instance<String> callSid;

	@Inject
	@From
	Instance<String> from;

	@Inject
	@RecordingUrl
	Instance<String> recordingUrl;

	private User user;

	int count = 0;

	public UserController() {
	}

	public boolean isNewUser() {
		System.out.println(getFrom() + " " + getCallSid());
		if (getFrom() != null && userRepository.exist(getFrom())) {
			return false;
		} else {
			this.user = new User(getFrom());
			return true;
		}

	}

	public String getCallSid() {
		return callSid.get();
	}

	public String getFrom() {
		return from.get();
	}

	public String getRecordingUrl() {
		return recordingUrl.get();
	}

	public void saveUser() {
		getUser().setMsgUrl(getRecordingUrl());
		userRepository.save(getUser());
		log();
	}

	public void log() {
		count++;
		System.out.println("CALL SID: " + getCallSid() + " count: " + count);
	}

	public User getUser() {
		return user;
	}

}
----
Vediamo le caratteristiche principali di questo controller:

. +@TwilioScope+: rappresenta lo scope del nostro controller che ha un ciclo di vita dipendente dalle informazioni 
che ci trasmette twilio: nasce appena viene effettuata la telefonata, 
con l'identificativo di chiamata (e' il @CallSid - parametro trasmesso da twilio alla prima interazione)
finisce appena twilio invoca il ns callbackUrl (sempre con il callSid andiamo a distruggere gli oggetti a lui agganciati
- ovvero 1 controller)

. +@Inject @CallSid Instance<String> callSid+: non ci iniettiamo la variabile come String ma come Instance<String> (
abbiamo bisogno di conoscere il suo valore aggiornato in tutto il ciclo di vita del ns controller) - se avessimo
usato @Inject @CallSid String callSid, per tutto il ciclo di vita del Controller, avremmo usato il valore del 
parametro CallSid assunto durante la costruzione del controller.

. +UserController implements TwilioScoped+: l'interfaccia è obbligatoria (in questa release di twiliofaces) per permettere
alla estensione di gestire il ciclo di vita del controller (è il metodo public String getCallSid() che viene invocato per 
determinare se il controller in uso è nuovo o è già gestito)


*Caso d'uso: tramite form web, richiediamo un numero di cellulare, la tipologia di azione da eseguire (sms o chiamata), 
la data in cui effettuare tale azione ed un messaggio testuale da leggere o da inviare come sms*

https://github.com/twiliofaces/twilioform-example[vedi esempio completo]

pagina jsf per raccolta informazioni:

----

----

java controller che effettua la chiamata o invia sms:

----

----


java timer che schedula la chiamata (quello che invia sms è simile):

----

----



== Conclusioni

- twilio rende semplice integrazione telefonica.
- con twiliofaces l'integrazione in java ee diventa molto piu' semplice!


==  Riferimenti
- https://www.twilio.com/try-twilio[twilio signup]
- http://www.twilio.com/docs[twilio tutorial/howto's]
- https://github.com/twiliofaces/twiliofaces/[twiliofaces source code]
- https://github.com/twilio/twilio-java[twilio-sdk source]


*http://asciidoctor.org/[tutorial generato usando asciidoc/asciidoctor]*
